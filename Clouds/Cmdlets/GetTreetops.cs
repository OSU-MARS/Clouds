using Mars.Clouds.Extensions;
using Mars.Clouds.GdalExtensions;
using Mars.Clouds.Las;
using Mars.Clouds.Segmentation;
using System;
using System.Diagnostics;
using System.IO;
using System.Management.Automation;
using System.Threading;

namespace Mars.Clouds.Cmdlets
{
    [Cmdlet(VerbsCommon.Get, "Treetops")]
    public class GetTreetops : GdalCmdlet
    {
        private readonly CancellationTokenSource cancellationTokenSource;

        [Parameter(Mandatory = true, Position = 0, HelpMessage = "1) path to a single digital surface model (DSM) raster to locate treetops within, 2) wildcarded path to a set of DSM tiles to process, or 3) path to a directory of DSM GeoTIFF files (.tif extension) to process. Each file must contain DigitalSurfaceModel's required bands.")]
        [ValidateNotNullOrWhiteSpace]
        public string Dsm { get; set; }

        [Parameter(HelpMessage = "Method of treetop detection. ChmRadius = local maxima by height dependent radius, Ring = ring prominence (default).")]
        public TreetopDetectionMethod Method { get; set; }

        [Parameter(HelpMessage = "Minimum canopy height above ground to be considered a possible treetop. Default is 1.5 m, which is automatically converted to feet if the DSM CRS is in English units. If any other value is specified it is used without conversion.")]
        [ValidateRange(0.0F, 100.0F)]
        public float MinimumHeight { get; set; }

        [Parameter(HelpMessage = "Name of band to use for surface heights in DSM raster. Default is to use '" + DigitalSurfaceModel.SurfaceBandName + "' if -" + nameof(this.Method) + " is DsmRadius or DsmRing and '" + DigitalSurfaceModel.CanopyHeightBandName + "' if -" + nameof(this.Method) + " is ChmRadius. Specify another band name to search other surfaces generated by Get-Dsm or use another name if -" + nameof(this.Dsm) + " indicates files with different band structure.")]
        [ValidateNotNullOrEmpty]
        public string? SurfaceBand { get; set; }

        [Parameter(Mandatory = true, Position = 2, HelpMessage = "1) path to write treetop candidates to as an XYZ point layer with fields treeID and height or 2,3) path to a directory to write treetop candidate .gpkg tiles to.")]
        [ValidateNotNullOrWhiteSpace]
        public string Treetops { get; set; }

        public GetTreetops()
        {
            this.cancellationTokenSource = new();

            this.Dsm = String.Empty; // mandatory
            // leave this.MaxThreads at default
            this.Method = TreetopDetectionMethod.DsmRing;
            this.MinimumHeight = Single.NaN;
            this.SurfaceBand = null;
            this.Treetops = String.Empty; // mandatory
        }

        protected override void ProcessRecord()
        {
            const string cmdletName = "Get-Treetops";
            TreetopSearch treetopSearch = this.Method switch
            {
                TreetopDetectionMethod.ChmRadius => new TreetopRadiusSearch(this.SurfaceBand ?? DigitalSurfaceModel.CanopyHeightBandName) { SearchInHeight = true },
                TreetopDetectionMethod.DsmRadius => new TreetopRadiusSearch(this.SurfaceBand ?? DigitalSurfaceModel.SurfaceBandName),
                TreetopDetectionMethod.DsmRing => new TreetopRingSearch(this.SurfaceBand ?? DigitalSurfaceModel.SurfaceBandName),
                _ => throw new NotSupportedException("Unhandled treetop detection method " + this.Method + ".")
            };

            // load all DSM tiles
            VirtualRaster<DigitalSurfaceModel> dsm = this.ReadVirtualRaster<DigitalSurfaceModel>(cmdletName, this.Dsm, readData: true, this.cancellationTokenSource);
            if ((dsm.NonNullTileCount > 1) && (Directory.Exists(this.Treetops) == false))
            {
                throw new ParameterOutOfRangeException(nameof(this.Treetops), "-" + nameof(this.Treetops) + " must be an existing directory when -" + nameof(this.Dsm) + " indicates multiple files.");
            }

            // find treetop candidates in all tiles
            int maxDsmTileIndex = treetopSearch.Dsm.VirtualRasterSizeInTilesX * treetopSearch.Dsm.VirtualRasterSizeInTilesY;
            string? mostRecentDsmTileName = null;
            int treetopCandidates = 0;
            int treetopFindsInitiated = -1;
            int treetopFindsCompleted = 0;
            ParallelTasks findTreetopsTasks = new(Int32.Min(this.MaxThreads, dsm.NonNullTileCount), () =>
            {
                for (int tileIndex = Interlocked.Increment(ref treetopFindsInitiated); tileIndex < maxDsmTileIndex; tileIndex = Interlocked.Increment(ref treetopFindsInitiated))
                {
                    DigitalSurfaceModel? dsmTile = treetopSearch.Dsm[tileIndex];
                    if (dsmTile == null)
                    {
                        continue;
                    }

                    string dsmTilePath = dsmTile.FilePath;
                    Debug.Assert(String.IsNullOrWhiteSpace(dsmTilePath) == false);

                    string dsmFileName = Path.GetFileName(dsmTilePath);
                    string dsmFileNameWithoutExtension = Path.GetFileNameWithoutExtension(dsmFileName);
                    string treetopTilePath = Path.Combine(this.Treetops, dsmFileNameWithoutExtension + Constant.File.GeoPackageExtension);

                    (int tileIndexX, int tileIndexY) = treetopSearch.Dsm.ToGridIndices(tileIndex);
                    int treetopCandidatesInTile = treetopSearch.FindTreetops(tileIndexX, tileIndexY, treetopTilePath);

                    lock (treetopSearch)
                    {
                        treetopCandidates += treetopCandidatesInTile;
                        ++treetopFindsCompleted;
                    }
                    mostRecentDsmTileName = dsmFileName;
                }
            }, this.cancellationTokenSource);

            TimedProgressRecord progress = new(cmdletName, "placeholder");
            while (findTreetopsTasks.WaitAll(Constant.DefaultProgressInterval) == false)
            {
                progress.StatusDescription = mostRecentDsmTileName != null ? "Finding treetops in " + mostRecentDsmTileName + "..." : "Finding treetops...";
                progress.Update(treetopFindsCompleted, dsm.NonNullTileCount);
                this.WriteProgress(progress);
            }

            progress.Stopwatch.Stop();
            string tileOrTiles = dsm.NonNullTileCount > 1 ? "tiles" : "tile";
            this.WriteVerbose(dsm.NonNullTileCount + " " + tileOrTiles + " and " + treetopCandidates.ToString("n0") + " treetop candidates in " + progress.Stopwatch.ToElapsedString() + ".");
            base.ProcessRecord();
        }

        protected override void StopProcessing()
        {
            this.cancellationTokenSource?.Cancel();
            base.StopProcessing();
        }
    }
}