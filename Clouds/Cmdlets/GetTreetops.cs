using Mars.Clouds.Extensions;
using Mars.Clouds.GdalExtensions;
using Mars.Clouds.Las;
using Mars.Clouds.Segmentation;
using System;
using System.Diagnostics;
using System.IO;
using System.Management.Automation;
using System.Threading;

namespace Mars.Clouds.Cmdlets
{
    [Cmdlet(VerbsCommon.Get, "Treetops")]
    public class GetTreetops : GdalCmdlet
    {
        [Parameter(Mandatory = true, Position = 0, HelpMessage = "1) path to a single digital surface model (DSM) raster to locate treetops within, 2) wildcarded path to a set of DSM tiles to process, or 3) path to a directory of DSM GeoTIFF files (.tif extension) to process. Each file must contain DigitalSurfaceModel's required bands.")]
        [ValidateNotNullOrWhiteSpace]
        public string Dsm { get; set; }

        [Parameter(HelpMessage = "Method of treetop detection. ChmRadius = local maxima by height dependent radius, Ring = ring prominence (default).")]
        public TreetopDetectionMethod Method { get; set; }

        [Parameter(HelpMessage = "Minimum canopy height above ground to be considered a possible treetop. Default is 1.5 m, which is automatically converted to feet if the DSM CRS is in English units. If any other value is specified it is used without conversion.")]
        [ValidateRange(0.0F, 100.0F)]
        public float MinimumHeight { get; set; }

        [Parameter(HelpMessage = $"Name of band to use for surface heights in DSM raster. Default is to use '{DigitalSurfaceModel.SurfaceBandName}' if -{nameof(this.Method)} is DsmRadius or DsmRing and '{DigitalSurfaceModel.CanopyHeightBandName}' if -{nameof(this.Method)} is ChmRadius. Specify another band name to search other surfaces generated by Get-Dsm or use another name if -{nameof(this.Dsm)} indicates files with different band structure.")]
        [ValidateNotNullOrEmpty]
        public string? SurfaceBand { get; set; }

        [Parameter(Mandatory = true, Position = 2, HelpMessage = "1) path to write treetop candidates to as an XYZ point layer with fields treeID and height or 2,3) path to a directory to write treetop candidate .gpkg tiles to.")]
        [ValidateNotNullOrWhiteSpace]
        public string Treetops { get; set; }

        public GetTreetops()
        {
            // leave this.DataThreads at default
            this.Dsm = String.Empty; // mandatory
            // leave this.MetadataThreads at default
            this.Method = TreetopDetectionMethod.DsmRing;
            this.MinimumHeight = Single.NaN;
            this.SurfaceBand = null;
            this.Treetops = String.Empty; // mandatory
        }

        protected override void ProcessRecord()
        {
            const string cmdletName = "Get-Treetops";
            VirtualRaster<DigitalSurfaceModel> dsm = this.ReadVirtualRasterMetadata<DigitalSurfaceModel>(cmdletName, this.Dsm, DigitalSurfaceModel.CreateFromPrimaryBandMetadata, this.CancellationTokenSource);
            Debug.Assert(dsm.TileGrid != null);

            bool treetopsPathIsDirectory = Directory.Exists(this.Treetops);
            if ((dsm.NonNullTileCount > 1) && (treetopsPathIsDirectory == false))
            {
                throw new ParameterOutOfRangeException(nameof(this.Treetops), $"-{nameof(this.Treetops)} must be an existing directory when -{nameof(this.Dsm)} indicates multiple files.");
            }

            TreetopSearch treetopSearch = this.Method switch
            {
                TreetopDetectionMethod.ChmRadius => TreetopRadiusSearch.Create(dsm, this.SurfaceBand, searchChm: true, treetopsPathIsDirectory),
                TreetopDetectionMethod.DsmRadius => TreetopRadiusSearch.Create(dsm, this.SurfaceBand, searchChm: false, treetopsPathIsDirectory),
                TreetopDetectionMethod.DsmRing => TreetopRingSearch.Create(dsm, this.SurfaceBand, treetopsPathIsDirectory),
                _ => throw new NotSupportedException($"Unhandled treetop detection method {this.Method}.")
            };

            // find treetop candidates in all tiles
            string? mostRecentDsmTileName = null;
            int treetopCandidates = 0;
            ParallelTasks findTreetopsTasks = new(Int32.Min(this.DataThreads, dsm.NonNullTileCount), () =>
            {
                for (int tileWriteIndex = treetopSearch.GetNextTileWriteIndexThreadSafe(); tileWriteIndex < treetopSearch.MaxTileIndex; tileWriteIndex = treetopSearch.GetNextTileWriteIndexThreadSafe())
                {
                    DigitalSurfaceModel? dsmTile = dsm[tileWriteIndex];
                    if (dsmTile == null)
                    {
                        continue;
                    }

                    if (treetopSearch.TryEnsureNeighborhoodRead(tileWriteIndex, dsm, this.CancellationTokenSource) == false)
                    {
                        Debug.Assert(this.CancellationTokenSource.IsCancellationRequested);
                        return; // reading was aborted
                    }

                    string tileName = Tile.GetName(dsmTile.FilePath);
                    string treetopTilePath = treetopsPathIsDirectory ? Path.Combine(this.Treetops, tileName + Constant.File.GeoPackageExtension) : this.Treetops;

                    (int tileIndexX, int tileIndexY) = dsm.ToGridIndices(tileWriteIndex);
                    int treetopCandidatesInTile = treetopSearch.FindTreetops(tileIndexX, tileIndexY, tileName, treetopTilePath);

                    lock (treetopSearch)
                    {
                        treetopSearch.OnTileWritten(tileIndexX, tileIndexY);
                        treetopCandidates += treetopCandidatesInTile;
                    }
                    mostRecentDsmTileName = tileName;
                }
            }, this.CancellationTokenSource);

            TimedProgressRecord progress = new(cmdletName, "placeholder");
            while (findTreetopsTasks.WaitAll(Constant.DefaultProgressInterval) == false)
            {
                progress.StatusDescription = treetopSearch.TilesRead + (treetopSearch.TilesRead == 1 ? " DSM read, " : " DSMs read, ") +
                                             treetopSearch.TilesWritten + " of " + dsm.NonNullTileCount + " treetop tiles written (" + 
                                             findTreetopsTasks.Count + (findTreetopsTasks.Count == 1 ? " thread)..." : " threads)...");
                progress.Update(treetopSearch.TilesWritten, dsm.NonNullTileCount);
                this.WriteProgress(progress);
            }

            progress.Stopwatch.Stop();
            string tileOrTiles = dsm.NonNullTileCount > 1 ? "tiles" : "tile";
            this.WriteVerbose($"{dsm.NonNullTileCount} {tileOrTiles} and {treetopCandidates:n0} treetop candidates in {progress.Stopwatch.ToElapsedString()}.");
            base.ProcessRecord();
        }
    }
}