using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace Mars.Clouds.Segmentation
{
    internal class Ring
    {
        public static readonly ReadOnlyCollection<Ring> Rings;

        public int[] XIndices { get; private set; }
        public int[] YIndices { get; private set; }

        static Ring()
        {
            Ring.Rings = new List<Ring>()
            {
                new([ -1, -1, -1, 0, 0, 1, 1, 1 ], [ -1, 0, 1, -1, 1, -1, 0, 1 ]), // radius 1
                new([ -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2 ], [ -1, 0, 1, -2, 2, -2, 2, -2, 2, -1, 0, 1 ]), // radius 2
                new([ -3, -3, -3, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 3, 3, 3 ], [ -1, 0, 1, -2, 2, -3, 3, -3, 3, -3, 3, -2, 2, -1, 0, 1 ]), // radius 3
                new([ -4, -4, -4, -4, -4, -3, -3, -3, -3, -2, -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4 ], [ -2, -1, 0, 1, 2, -3, -2, 2, 3, -4, -3, 3, 4, -4, 4, -4, 4, -4, 4, -4, -3, 3, 4, -3, -2, 2, 3, -2, -1, 0, 1, 2 ]), // radius 4
                new([ -5, -5, -5, -5, -5, -4, -4, -3, -3, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 5, 5, 5 ], [ -2, -1, 0, 1, 2, -3, 3, -4, 4, -5, 5, -5, 5, -5, 5, -5, 5, -5, 5, -4, 4, -3, 3, -2, -1, 0, 1, 2 ]), // radius 5
                new([ -6, -6, -6, -6, -6, -5, -5, -5, -5, -4, -4, -4, -4, -3, -3, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6 ], [ -2, -1, 0, 1, 2, -4, -3, 3, 4, -5, -4, 4, 5, -5, 5, -6, 6, -6, 6, -6, 6, -6, 6, -6, 6, -5, 5, -5, -4, 4, 5, -4, -3, 3, 4, -2, -1, 0, 1, 2 ]), // radius 6
                new([ -7, -7, -7, -7, -7, -6, -6, -6, -6, -5, -5, -4, -4, -3, -3, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 7 ], [ -2, -1, 0, 1, 2, -4, -3, 3, 4, -5, 5, -6, 6, -6, 6, -7, 7, -7, 7, -7, 7, -7, 7, -7, 7, -6, 6, -6, 6, -5, 5, -4, -3, 3, 4, -2, -1, 0, 1, 2 ]), // radius 7
                new([ -8, -8, -8, -8, -8, -7, -7, -7, -7, -6, -6, -6, -6, -5, -5, -4, -4, -3, -3, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8 ], [ -2, -1, 0, 1, 2, -4, -3, 3, 4, -6, -5, 5, 6, -6, 6, -7, 7, -7, 7, -8, 8, -8, 8, -8, 8, -8, 8, -8, 8, -7, 7, -7, 7, -6, 6, -6, -5, 5, 6, -4, -3, 3, 4, -2, -1, 0, 1, 2 ]), // 8
                new([ -9, -9, -9, -9, -9, -9, -9, -8, -8, -8, -8, -8, -8, -7, -7, -7, -7, -6, -6, -5, -5, -5, -5, -4, -4, -3, -3, -3, -3, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9 ], [ -3, -2, -1, 0, 1, 2, 3, -5, -4, -3, 3, 4, 5, -6, -5, 5, 6, -7, 7, -8, -7, 7, 8, -8, 8, -9, -8, 8, 9, -9, 9, -9, 9, -9, 9, -9, 9, -9, 9, -9, -8, 8, 9, -8, 8, -8, -7, 7, 8, -7, 7, -6, -5, 5, 6, -5, -4, -3, 3, 4, 5, -3, -2, -1, 0, 1, 2, 3 ]), // 9
                new([ -10, -10, -10, -10, -10, -10, -10, -9, -9, -9, -9, -8, -8, -7, -7, -6, -6, -5, -5, -4, -4, -3, -3, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10 ], [ -3, -2, -1, 0, 1, 2, 3, -5, -4, 4, 5, -6, 6, -7, 7, -8, 8, -9, 9, -9, 9, -10, 10, -10, 10, -10, 10, -10, 10, -10, 10, -10, 10, -10, 10, -9, 9, -9, 9, -8, 8, -7, 7, -6, 6, -5, -4, 4, 5, -3, -2, -1, 0, 1, 2, 3 ]), // 10
            }.AsReadOnly();
        }

        public Ring(int[] xIndices, int[] yIndices)
        {
            if (xIndices.Length != yIndices.Length)
            {
                throw new ArgumentOutOfRangeException(nameof(yIndices), "X index sets must match. X indices are of length " + xIndices.Length + " but y indices are of length " + yIndices.Length + ".");
            }

            this.XIndices = xIndices;
            this.YIndices = yIndices;
        }

        public int Count
        {
            get { return this.XIndices.Length; }
        }
    }
}
